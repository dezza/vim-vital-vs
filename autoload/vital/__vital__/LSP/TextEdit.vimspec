let s:expect = themis#helper('expect')
let s:filepath = globpath(&runtimepath, 'autoload/vital/__vital__/LSP/Position.vimspec')
let s:TextEdit = vital#vital#import('LSP.TextEdit')

Describe vital#__vital__#LSP#TextEdit

  Describe #apply

    " @see https://github.com/microsoft/vscode-languageserver-node/blob/master/textDocument/src/test/edits.test.ts

    It should edit inserts 1
      call s:apply("012345678901234567890123456789", [{
      \   'start': [0, 0],
      \   'end': [0, 0],
      \   'text': 'Hello'
      \ }], "Hello012345678901234567890123456789")
    End

    It should edit inserts 2
      call s:apply("012345678901234567890123456789", [{
      \   'start': [0, 1],
      \   'end': [0, 1],
      \   'text': 'Hello'
      \ }], "0Hello12345678901234567890123456789")
    End

    It should edit inserts 3
      call s:apply("012345678901234567890123456789", [{
      \   'start': [0, 1],
      \   'end': [0, 1],
      \   'text': 'Hello'
      \ },{
      \   'start': [0, 1],
      \   'end': [0, 1],
      \   'text': 'World'
      \ }], "0HelloWorld12345678901234567890123456789")
    End

    It should edit inserts 4
      call s:apply("012345678901234567890123456789", [{
      \   'start': [0, 2],
      \   'end': [0, 2],
      \   'text': 'One'
      \ },{
      \   'start': [0, 1],
      \   'end': [0, 1],
      \   'text': 'Hello'
      \ },{
      \   'start': [0, 1],
      \   'end': [0, 1],
      \   'text': 'World'
      \ },{
      \   'start': [0, 2],
      \   'end': [0, 2],
      \   'text': 'Two'
      \ },{
      \   'start': [0, 2],
      \   'end': [0, 2],
      \   'text': 'Three'
      \ }], "0HelloWorld1OneTwoThree2345678901234567890123456789")
    End

    It should edit replaces 1
      call s:apply("012345678901234567890123456789", [{
      \   'start': [0, 3],
      \   'end': [0, 6],
      \   'text': 'Hello'
      \ }], "012Hello678901234567890123456789")
    End

    It should edit replaces 2
      call s:apply("012345678901234567890123456789", [{
      \   'start': [0, 3],
      \   'end': [0, 6],
      \   'text': 'Hello'
      \ }, {
      \   'start': [0, 6],
      \   'end': [0, 9],
      \   'text': 'World'
      \ }], "012HelloWorld901234567890123456789")
    End

    It should edit replaces 3
      call s:apply("012345678901234567890123456789", [{
      \   'start': [0, 3],
      \   'end': [0, 6],
      \   'text': 'Hello'
      \ }, {
      \   'start': [0, 6],
      \   'end': [0, 6],
      \   'text': 'World'
      \ }], "012HelloWorld678901234567890123456789")
    End

    It should edit replaces 4
      call s:apply("012345678901234567890123456789", [{
      \   'start': [0, 6],
      \   'end': [0, 6],
      \   'text': 'World'
      \ }, {
      \   'start': [0, 3],
      \   'end': [0, 6],
      \   'text': 'Hello'
      \ }], "012HelloWorld678901234567890123456789")
    End

    It should edit replaces 5
      call s:apply("012345678901234567890123456789", [{
      \   'start': [0, 3],
      \   'end': [0, 3],
      \   'text': 'World'
      \ }, {
      \   'start': [0, 3],
      \   'end': [0, 6],
      \   'text': 'Hello'
      \ }], "012WorldHello678901234567890123456789")
    End

    It should edit multiline 1
      call s:apply("0\n1\n2\n3\n4", [{
      \   'start': [2, 0],
      \   'end': [3, 0],
      \   'text': 'Hello'
      \ }, {
      \   'start': [1, 1],
      \   'end': [1, 1],
      \   'text': 'World'
      \ }], "0\n1World\nHello3\n4")
    End

    It should throw overlap error 1
      let s:catch = v:false
      try
        call s:apply("012345678901234567890123456789", [{
        \   'start': [0, 3],
        \   'end': [0, 6],
        \   'text': 'Hello'
        \ }, {
        \   'start': [0, 3],
        \   'end': [0, 3],
        \   'text': 'World'
        \ }])
      catch /.*/
        let s:catch = v:true
      endtry
      call s:expect(s:catch).to_equal(v:true)
    End

    It should throw overlap error 2
      let s:catch = v:false
      try
        call s:apply("012345678901234567890123456789", [{
        \   'start': [0, 3],
        \   'end': [0, 6],
        \   'text': 'Hello'
        \ }, {
        \   'start': [0, 3],
        \   'end': [0, 4],
        \   'text': 'World'
        \ }])
      catch /.*/
        let s:catch = v:true
      endtry
      call s:expect(s:catch).to_equal(v:true)
    End

    It should delete multiline 1
      call s:apply("abcdefg\nhijklmn\nopqrstu\nvwxyg", [{
      \   'start': [0, 0],
      \   'end': [1, 0],
      \   'text': ''
      \ }, {
      \   'start': [1, 0],
      \   'end': [2, 0],
      \   'text': ''
      \ }], "opqrstu\nvwxyg")
    End

    It should delete multiline 2
      call s:apply("abcdefg\nhijklmn\nopqrstu\nvwxyg", [{
      \   'start': [0, 0],
      \   'end': [1, 4],
      \   'text': ''
      \ }, {
      \   'start': [1, 4],
      \   'end': [2, 4],
      \   'text': ''
      \ }], "stu\nvwxyg")
    End

    It should add/delete multiline 1
      call s:apply("abcdefg\nhijklmn\nopqrstu\nvwxyg", [{
      \   'start': [0, 0],
      \   'end': [1, 0],
      \   'text': "12345\n"
      \ }, {
      \   'start': [1, 0],
      \   'end': [2, 0],
      \   'text': "67890\n"
      \ }], "12345\n67890\nopqrstu\nvwxyg")
    End

    It should add/delete multiline 2
      call s:apply("abcdefg\nhijklmn\nopqrstu\nvwxyg", [{
      \   'start': [0, 0],
      \   'end': [1, 4],
      \   'text': ''
      \ }, {
      \   'start': [1, 4],
      \   'end': [2, 4],
      \   'text': ''
      \ }], "stu\nvwxyg")
    End

  End

End

function! s:buffer(content) abort
  enew!
  let l:content = type(a:content) == type([])
  \   ? a:content
  \   : split(a:content, "\n", v:true)
  put!=l:content
  normal! Gdd
endfunction

function! s:apply(content, text_edits, expected) abort
  call s:buffer(a:content)
  call s:TextEdit.apply(bufnr('%'), map(a:text_edits, { _, text_edit -> {
  \   'range': {
  \     'start': {
  \       'line': text_edit.start[0],
  \       'character': text_edit.start[1],
  \     },
  \     'end': {
  \       'line': text_edit.end[0],
  \       'character': text_edit.end[1],
  \     },
  \   },
  \   'newText': text_edit.text
  \ } }))

  call s:expect(split(a:expected, "\n", v:true)).to_equal(getline('^', '$'))
endfunction

